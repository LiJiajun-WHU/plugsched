diff --git a/scheduler/kernel/sched/mod/fair.c b/scheduler/kernel/sched/mod/fair.c
--- a/scheduler/kernel/sched/mod/fair.c
+++ b/scheduler/kernel/sched/mod/fair.c
@@ -600,6 +600,29 @@ static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)
 return slice;
 }
 
+/*
+ * Calculate virtual deadline for EEVDF scheduler
+ * deadline = vruntime + slice
+ * Note: This is a simplified example. In production, integrate with
+ * existing EEVDF deadline update mechanisms for consistency.
+ */
+static void update_deadline_exp(struct cfs_rq *cfs_rq, struct sched_entity *se)
+{
+u64 slice = sched_slice(cfs_rq, se);
+
+if (sched_feat(EEVDF_DEADLINE_EXP)) {
+// Experimental: adjust slice based on task nice value
+struct task_struct *p = task_of(se);
+int nice = task_nice(p);
+if (nice < 0) {
+// High priority: shorter deadline (~25% reduction using shift)
+slice -= slice >> 2;
+}
+}
+
+// In real implementation, use EEVDF's deadline management API
+se->deadline = se->vruntime + slice;
+}
+
 /*
  * We calculate the wall-clock slice from the period by taking a part
  * proportional to the weight.
@@ -800,6 +823,9 @@ static void update_curr(struct cfs_rq *cfs_rq)
 curr->vruntime += calc_delta_fair(delta_exec, curr);
 update_min_vruntime(cfs_rq);
 
+// Update deadline for EEVDF (experimental)
+update_deadline_exp(cfs_rq, curr);
+
 if (entity_is_task(curr)) {
 struct task_struct *curtask = task_of(curr);
 
diff --git a/scheduler/kernel/sched/mod/features.h b/scheduler/kernel/sched/mod/features.h
--- a/scheduler/kernel/sched/mod/features.h
+++ b/scheduler/kernel/sched/mod/features.h
@@ -1,4 +1,10 @@
 /* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * EEVDF virtual deadline calculation experiment
+ * Experimental modification to EEVDF deadline calculation
+ */
+SCHED_FEAT(EEVDF_DEADLINE_EXP, false)
 
 /*
  * Only give sleepers 50% of their service deficit. This allows
